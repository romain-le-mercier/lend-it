{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nexports.__esModule = true;\nexports.default = void 0;\nexports.setExperimentalAllowsFatalError = setExperimentalAllowsFatalError;\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\nvar _rx = require(\"../utils/rx\");\nvar _common = require(\"../utils/common\");\nvar _fp = require(\"../utils/fp\");\nvar _compat = _interopRequireDefault(require(\"../adapters/compat\"));\nvar _CollectionMap = _interopRequireDefault(require(\"./CollectionMap\"));\nvar _WorkQueue = _interopRequireDefault(require(\"./WorkQueue\"));\nvar experimentalAllowsFatalError = false;\nfunction setExperimentalAllowsFatalError() {\n  experimentalAllowsFatalError = true;\n}\nvar Database = function () {\n  function Database(options) {\n    this._workQueue = new _WorkQueue.default(this);\n    this._isBroken = false;\n    this._pendingNotificationBatches = 0;\n    this._pendingNotificationChanges = [];\n    this._subscribers = [];\n    this._resetCount = 0;\n    this._isBeingReset = false;\n    var adapter = options.adapter,\n      modelClasses = options.modelClasses;\n    if ('production' !== process.env.NODE_ENV) {\n      (0, _common.invariant)(adapter, \"Missing adapter parameter for new Database()\");\n      (0, _common.invariant)(modelClasses && Array.isArray(modelClasses), \"Missing modelClasses parameter for new Database()\");\n    }\n    this.adapter = new _compat.default(adapter);\n    this.schema = adapter.schema;\n    this.collections = new _CollectionMap.default(this, modelClasses);\n  }\n  var _proto = Database.prototype;\n  _proto.get = function get(tableName) {\n    return this.collections.get(tableName);\n  };\n  _proto.batch = function batch() {\n    for (var _len = arguments.length, records = new Array(_len), _key = 0; _key < _len; _key++) {\n      records[_key] = arguments[_key];\n    }\n    return new Promise(function ($return, $error) {\n      var _this, actualRecords, batchOperations, changeNotifications, changes;\n      _this = this;\n      actualRecords = (0, _fp.fromArrayOrSpread)(records, 'Database.batch', 'Model');\n      this._ensureInWriter(\"Database.batch()\");\n      batchOperations = [];\n      changeNotifications = {};\n      actualRecords.forEach(function (record) {\n        if (!record) {\n          return;\n        }\n        var preparedState = record._preparedState;\n        if (!preparedState) {\n          (0, _common.invariant)('disposable' !== record._raw._status, \"Cannot batch a disposable record\");\n          throw new Error(\"Cannot batch a record that doesn't have a prepared create/update/delete\");\n        }\n        var raw = record._raw;\n        var id = raw.id;\n        var table = record.constructor.table;\n        var changeType;\n        if ('update' === preparedState) {\n          batchOperations.push(['update', table, raw]);\n          changeType = 'updated';\n        } else if ('create' === preparedState) {\n          batchOperations.push(['create', table, raw]);\n          changeType = 'created';\n        } else if ('markAsDeleted' === preparedState) {\n          batchOperations.push(['markAsDeleted', table, id]);\n          changeType = 'destroyed';\n        } else if ('destroyPermanently' === preparedState) {\n          batchOperations.push(['destroyPermanently', table, id]);\n          changeType = 'destroyed';\n        } else {\n          (0, _common.invariant)(false, 'bad preparedState');\n        }\n        if ('create' !== preparedState) {\n          record._preparedState = null;\n        }\n        if (!changeNotifications[table]) {\n          changeNotifications[table] = [];\n        }\n        changeNotifications[table].push({\n          record: record,\n          type: changeType\n        });\n      });\n      return Promise.resolve(this.adapter.batch(batchOperations)).then(function () {\n        try {\n          changes = Object.entries(changeNotifications);\n          changes.forEach(function (_ref) {\n            var _ref2 = _slicedToArray(_ref, 2),\n              table = _ref2[0],\n              changeSet = _ref2[1];\n            _this.collections.get(table)._applyChangesToCache(changeSet);\n          });\n          this._notify(changes);\n          return $return(undefined);\n        } catch ($boundEx) {\n          return $error($boundEx);\n        }\n      }.bind(this), $error);\n    }.bind(this));\n  };\n  _proto._notify = function _notify(changes) {\n    var _this2 = this;\n    if (0 < this._pendingNotificationBatches) {\n      this._pendingNotificationChanges.push(changes);\n      return;\n    }\n    var affectedTables = new Set(changes.map(function (_ref3) {\n      var _ref4 = _slicedToArray(_ref3, 1),\n        table = _ref4[0];\n      return table;\n    }));\n    this._subscribers.forEach(function databaseChangeNotifySubscribers(_ref5) {\n      var _ref6 = _slicedToArray(_ref5, 2),\n        tables = _ref6[0],\n        subscriber = _ref6[1];\n      if (tables.some(function (table) {\n        return affectedTables.has(table);\n      })) {\n        subscriber();\n      }\n    });\n    changes.forEach(function (_ref7) {\n      var _ref8 = _slicedToArray(_ref7, 2),\n        table = _ref8[0],\n        changeSet = _ref8[1];\n      _this2.collections.get(table)._notify(changeSet);\n    });\n  };\n  _proto.experimentalBatchNotifications = function experimentalBatchNotifications(work) {\n    return new Promise(function ($return, $error) {\n      var $Try_1_Finally = function ($Try_1_Exit) {\n        return function ($Try_1_Value) {\n          try {\n            this._pendingNotificationBatches -= 1;\n            if (0 === this._pendingNotificationBatches) {\n              changes = this._pendingNotificationChanges;\n              this._pendingNotificationChanges = [];\n              changes.forEach(function (_changes) {\n                return _this3._notify(_changes);\n              });\n            }\n            return $Try_1_Exit && $Try_1_Exit.call(this, $Try_1_Value);\n          } catch ($boundEx) {\n            return $error($boundEx);\n          }\n        }.bind(this);\n      }.bind(this);\n      var _this3, result, changes;\n      _this3 = this;\n      var $Try_1_Catch = function $Try_1_Catch($exception_2) {\n        try {\n          throw $exception_2;\n        } catch ($boundEx) {\n          return $Try_1_Finally($error)($boundEx);\n        }\n      };\n      try {\n        this._pendingNotificationBatches += 1;\n        return Promise.resolve(work()).then(function ($await_6) {\n          try {\n            result = $await_6;\n            return $Try_1_Finally($return)(result);\n          } catch ($boundEx) {\n            return $Try_1_Catch($boundEx);\n          }\n        }, $Try_1_Catch);\n      } catch ($exception_2) {\n        $Try_1_Catch($exception_2);\n      }\n    }.bind(this));\n  };\n  _proto.write = function write(work, description) {\n    return this._workQueue.enqueue(work, description, true);\n  };\n  _proto.read = function read(work, description) {\n    return this._workQueue.enqueue(work, description, false);\n  };\n  _proto.withChangesForTables = function withChangesForTables(tables) {\n    var _this4 = this;\n    var changesSignals = tables.map(function (table) {\n      return _this4.collections.get(table).changes;\n    });\n    return _rx.merge.apply(void 0, (0, _toConsumableArray2.default)(changesSignals)).pipe((0, _rx.startWith)(null));\n  };\n  _proto.experimentalSubscribe = function experimentalSubscribe(tables, subscriber, debugInfo) {\n    var _this5 = this;\n    if (!tables.length) {\n      return _fp.noop;\n    }\n    var entry = [tables, subscriber, debugInfo];\n    this._subscribers.push(entry);\n    return function () {\n      var idx = _this5._subscribers.indexOf(entry);\n      -1 !== idx && _this5._subscribers.splice(idx, 1);\n    };\n  };\n  _proto.unsafeResetDatabase = function unsafeResetDatabase() {\n    return new Promise(function ($return, $error) {\n      var $Try_3_Finally = function ($Try_3_Exit) {\n        return function ($Try_3_Value) {\n          try {\n            this._isBeingReset = false;\n            return $Try_3_Exit && $Try_3_Exit.call(this, $Try_3_Value);\n          } catch ($boundEx) {\n            return $error($boundEx);\n          }\n        }.bind(this);\n      }.bind(this);\n      var adapter, ErrorAdapter;\n      this._ensureInWriter(\"Database.unsafeResetDatabase()\");\n      var $Try_3_Post = function $Try_3_Post() {\n        try {\n          return $return();\n        } catch ($boundEx) {\n          return $error($boundEx);\n        }\n      };\n      var $Try_3_Catch = function $Try_3_Catch($exception_4) {\n        try {\n          throw $exception_4;\n        } catch ($boundEx) {\n          return $Try_3_Finally($error)($boundEx);\n        }\n      };\n      try {\n        this._isBeingReset = true;\n        this._workQueue._abortPendingWork();\n        adapter = this.adapter;\n        ErrorAdapter = require(\"../adapters/error\").default;\n        this.adapter = new ErrorAdapter();\n        if (this._subscribers.length) {\n          console.log(\"Application error! Unexpected \".concat(this._subscribers.length, \" Database subscribers were detected during database.unsafeResetDatabase() call. App should not hold onto subscriptions or Watermelon objects while resetting database.\"));\n          console.log(this._subscribers);\n          this._subscribers = [];\n        }\n        return Promise.resolve(adapter.unsafeResetDatabase()).then(function () {\n          try {\n            Object.values(this.collections.map).forEach(function (collection) {\n              collection._cache.unsafeClear();\n            });\n            this._resetCount += 1;\n            this.adapter = adapter;\n            return $Try_3_Finally($Try_3_Post)();\n          } catch ($boundEx) {\n            return $Try_3_Catch($boundEx);\n          }\n        }.bind(this), $Try_3_Catch);\n      } catch ($exception_4) {\n        $Try_3_Catch($exception_4);\n      }\n    }.bind(this));\n  };\n  _proto._ensureInWriter = function _ensureInWriter(diagnosticMethodName) {\n    (0, _common.invariant)(this._workQueue.isWriterRunning, \"\".concat(diagnosticMethodName, \" can only be called from inside of a Writer. See docs for more details.\"));\n  };\n  _proto._fatalError = function _fatalError(error) {\n    if (!experimentalAllowsFatalError) {\n      _common.logger.warn('Database is now broken, but experimentalAllowsFatalError has not been enabled to do anything about it...');\n      return;\n    }\n    this._isBroken = true;\n    _common.logger.error('Database is broken. App must be reloaded before continuing.');\n    if (this.adapter.underlyingAdapter._fatalError) {\n      this.adapter.underlyingAdapter._fatalError(error);\n    }\n  };\n  (0, _createClass2.default)(Database, [{\n    key: \"localStorage\",\n    get: function get() {\n      if (!this._localStorage) {\n        var LocalStorageClass = require(\"./LocalStorage\").default;\n        this._localStorage = new LocalStorageClass(this);\n      }\n      return this._localStorage;\n    }\n  }]);\n  return Database;\n}();\nexports.default = Database;","map":{"version":3,"names":["_slicedToArray","require","_interopRequireDefault","exports","__esModule","default","setExperimentalAllowsFatalError","_toConsumableArray2","_createClass2","_rx","_common","_fp","_compat","_CollectionMap","_WorkQueue","experimentalAllowsFatalError","Database","options","_workQueue","_isBroken","_pendingNotificationBatches","_pendingNotificationChanges","_subscribers","_resetCount","_isBeingReset","adapter","modelClasses","process","env","NODE_ENV","invariant","Array","isArray","schema","collections","_proto","prototype","get","tableName","batch","_len","arguments","length","records","_key","Promise","$return","$error","_this","actualRecords","batchOperations","changeNotifications","changes","fromArrayOrSpread","_ensureInWriter","forEach","record","preparedState","_preparedState","_raw","_status","Error","raw","id","table","constructor","changeType","push","type","resolve","then","Object","entries","_ref","_ref2","changeSet","_applyChangesToCache","_notify","undefined","$boundEx","bind","_this2","affectedTables","Set","map","_ref3","_ref4","databaseChangeNotifySubscribers","_ref5","_ref6","tables","subscriber","some","has","_ref7","_ref8","experimentalBatchNotifications","work","$Try_1_Finally","$Try_1_Exit","$Try_1_Value","_changes","_this3","call","result","$Try_1_Catch","$exception_2","$await_6","write","description","enqueue","read","withChangesForTables","_this4","changesSignals","merge","apply","pipe","startWith","experimentalSubscribe","debugInfo","_this5","noop","entry","idx","indexOf","splice","unsafeResetDatabase","$Try_3_Finally","$Try_3_Exit","$Try_3_Value","ErrorAdapter","$Try_3_Post","$Try_3_Catch","$exception_4","_abortPendingWork","console","log","concat","values","collection","_cache","unsafeClear","diagnosticMethodName","isWriterRunning","_fatalError","error","logger","warn","underlyingAdapter","key","_localStorage","LocalStorageClass"],"sources":["/app/node_modules/@nozbe/watermelondb/Database/index.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nexports.__esModule = true;\nexports.default = void 0;\nexports.setExperimentalAllowsFatalError = setExperimentalAllowsFatalError;\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\nvar _rx = require(\"../utils/rx\");\nvar _common = require(\"../utils/common\");\nvar _fp = require(\"../utils/fp\");\nvar _compat = _interopRequireDefault(require(\"../adapters/compat\"));\nvar _CollectionMap = _interopRequireDefault(require(\"./CollectionMap\"));\nvar _WorkQueue = _interopRequireDefault(require(\"./WorkQueue\"));\nvar experimentalAllowsFatalError = false;\nfunction setExperimentalAllowsFatalError() {\n  experimentalAllowsFatalError = true;\n}\nvar Database = /*#__PURE__*/function () {\n  /**\n   * Database's adapter - the low-level connection with the underlying database (e.g. SQLite)\n   *\n   * Unless you understand WatermelonDB's internals, you SHOULD NOT use adapter directly.\n   * Running queries, or updating/deleting records on the adapter will corrupt the in-memory cache\n   * if special care is not taken\n   */\n\n  // (experimental) if true, Database is in a broken state and should not be used anymore\n\n  function Database(options) {\n    this._workQueue = new _WorkQueue.default(this);\n    this._isBroken = false;\n    this._pendingNotificationBatches = 0;\n    this._pendingNotificationChanges = [];\n    this._subscribers = [];\n    this._resetCount = 0;\n    this._isBeingReset = false;\n    var {\n      adapter: adapter,\n      modelClasses: modelClasses\n    } = options;\n    if ('production' !== process.env.NODE_ENV) {\n      (0, _common.invariant)(adapter, \"Missing adapter parameter for new Database()\");\n      (0, _common.invariant)(modelClasses && Array.isArray(modelClasses), \"Missing modelClasses parameter for new Database()\");\n    }\n    this.adapter = new _compat.default(adapter);\n    this.schema = adapter.schema;\n    this.collections = new _CollectionMap.default(this, modelClasses);\n  }\n\n  /**\n   * Returns a `Collection` for a given table name\n   */\n  var _proto = Database.prototype;\n  _proto.get = function get(tableName) {\n    return this.collections.get(tableName);\n  }\n\n  /**\n   * Returns a `LocalStorage` (WatermelonDB-based localStorage/AsyncStorage alternative)\n   */;\n  /*:: batch: ArrayOrSpreadFn<?Model | false, Promise<void>>  */\n  /**\n   * Executes multiple prepared operations\n   *\n   * Pass a list (or array) of operations like so:\n   * - `collection.prepareCreate(...)`\n   * - `record.prepareUpdate(...)`\n   * - `record.prepareMarkAsDeleted()` (or `record.prepareDestroyPermanently()`)\n   *\n   * Note that falsy values (null, undefined, false) passed to batch are simply ignored\n   * so you can use patterns like `.batch(condition && record.prepareUpdate(...))` for convenience.\n   *\n   * Note: This method must be called within a Writer {@link Database#write}.\n   */\n  // $FlowFixMe\n  _proto.batch = function batch(...records) {\n    return new Promise(function ($return, $error) {\n      var _this, actualRecords, batchOperations, changeNotifications, changes;\n      _this = this;\n      actualRecords = (0, _fp.fromArrayOrSpread)(records, 'Database.batch', 'Model');\n      this._ensureInWriter(\"Database.batch()\");\n\n      // performance critical - using mutations\n      batchOperations = [];\n      changeNotifications = {};\n      actualRecords.forEach(function (record) {\n        if (!record) {\n          return;\n        }\n        var preparedState = record._preparedState;\n        if (!preparedState) {\n          (0, _common.invariant)('disposable' !== record._raw._status, \"Cannot batch a disposable record\");\n          throw new Error(\"Cannot batch a record that doesn't have a prepared create/update/delete\");\n        }\n        var raw = record._raw;\n        var {\n          id: id\n        } = raw; // faster than Model.id\n        var {\n          table: table\n        } = record.constructor; // faster than Model.table\n\n        var changeType;\n        if ('update' === preparedState) {\n          batchOperations.push(['update', table, raw]);\n          changeType = 'updated';\n        } else if ('create' === preparedState) {\n          batchOperations.push(['create', table, raw]);\n          changeType = 'created';\n        } else if ('markAsDeleted' === preparedState) {\n          batchOperations.push(['markAsDeleted', table, id]);\n          changeType = 'destroyed';\n        } else if ('destroyPermanently' === preparedState) {\n          batchOperations.push(['destroyPermanently', table, id]);\n          changeType = 'destroyed';\n        } else {\n          (0, _common.invariant)(false, 'bad preparedState');\n        }\n        if ('create' !== preparedState) {\n          // We're (unsafely) assuming that batch will succeed and removing the \"pending\" state so that\n          // subsequent changes to the record don't trip up the invariant\n          // TODO: What if this fails?\n          record._preparedState = null;\n        }\n        if (!changeNotifications[table]) {\n          changeNotifications[table] = [];\n        }\n        changeNotifications[table].push({\n          record: record,\n          type: changeType\n        });\n      });\n      return Promise.resolve(this.adapter.batch(batchOperations)).then(function () {\n        try {\n          changes = Object.entries(changeNotifications);\n          changes.forEach(function ([table, changeSet]) {\n            _this.collections.get(table)._applyChangesToCache(changeSet);\n          });\n          this._notify(changes);\n          return $return(undefined); // shuts up flow\n        } catch ($boundEx) {\n          return $error($boundEx);\n        }\n      }.bind(this), $error);\n    }.bind(this));\n  };\n  _proto._notify = function _notify(changes) {\n    var _this2 = this;\n    if (0 < this._pendingNotificationBatches) {\n      this._pendingNotificationChanges.push(changes);\n      return;\n    }\n    var affectedTables = new Set(changes.map(function ([table]) {\n      return table;\n    }));\n    this._subscribers.forEach(function databaseChangeNotifySubscribers([tables, subscriber]) {\n      if (tables.some(function (table) {\n        return affectedTables.has(table);\n      })) {\n        subscriber();\n      }\n    });\n    changes.forEach(function ([table, changeSet]) {\n      _this2.collections.get(table)._notify(changeSet);\n    });\n  };\n  _proto.experimentalBatchNotifications = function experimentalBatchNotifications(work) {\n    return new Promise(function ($return, $error) {\n      var $Try_1_Finally = function ($Try_1_Exit) {\n        return function ($Try_1_Value) {\n          try {\n            this._pendingNotificationBatches -= 1;\n            if (0 === this._pendingNotificationBatches) {\n              changes = this._pendingNotificationChanges;\n              this._pendingNotificationChanges = [];\n              changes.forEach(function (_changes) {\n                return _this3._notify(_changes);\n              });\n            }\n            return $Try_1_Exit && $Try_1_Exit.call(this, $Try_1_Value);\n          } catch ($boundEx) {\n            return $error($boundEx);\n          }\n        }.bind(this);\n      }.bind(this);\n      var _this3, result, changes;\n      _this3 = this;\n      var $Try_1_Catch = function ($exception_2) {\n        try {\n          throw $exception_2;\n        } catch ($boundEx) {\n          return $Try_1_Finally($error)($boundEx);\n        }\n      };\n      // TODO: Document & add tests if this proves useful\n      try {\n        this._pendingNotificationBatches += 1;\n        return Promise.resolve(work()).then(function ($await_6) {\n          try {\n            result = $await_6;\n            return $Try_1_Finally($return)(result);\n          } catch ($boundEx) {\n            return $Try_1_Catch($boundEx);\n          }\n        }, $Try_1_Catch);\n      } catch ($exception_2) {\n        $Try_1_Catch($exception_2)\n      }\n    }.bind(this));\n  }\n\n  /**\n   * Schedules a Writer\n   *\n   * Writer is a block of code, inside of which you can modify the database\n   * (call `Collection.create`, `Model.update`, `Database.batch` and so on).\n   *\n   * In a Writer, you're guaranteed that no other Writer is simultaneously executing. Therefore, you\n   * can rely on the results of queries and other asynchronous operations - they won't change for\n   * the duration of this Writer (except if changed by it).\n   *\n   * To call another Writer (or Reader) from this one without deadlocking, use `callWriter`\n   * (or `callReader`).\n   *\n   * See docs for more details and a practical guide.\n   *\n   * @param work - Block of code to execute\n   * @param [description] - Debug description of this Writer\n   */;\n  _proto.write = function write(work, description) {\n    return this._workQueue.enqueue(work, description, true);\n  }\n\n  /**\n   * Schedules a Reader\n   *\n   * In a Reader, you're guaranteed that no Writer is running at the same time. Therefore, you can\n   * run many queries or other asynchronous operations, and you can rely on their results - they\n   * won't change for the duration of this Reader. However, other Readers might run concurrently.\n   *\n   * To call another Reader from this one, use `callReader`\n   *\n   * See docs for more details and a practical guide.\n   *\n   * @param work - Block of code to execute\n   * @param [description] - Debug description of this Reader\n   */;\n  _proto.read = function read(work, description) {\n    return this._workQueue.enqueue(work, description, false);\n  }\n\n  /**\n   * Returns an `Observable` that emits a signal (`null`) immediately, and on every change in\n   * any of the passed tables.\n   *\n   * A set of changes made is passed with the signal, with an array of changes per-table\n   * (Currently, if changes are made to multiple different tables, multiple signals will be emitted,\n   * even if they're made with a batch. However, this behavior might change. Use Rx to debounce,\n   * throttle, merge as appropriate for your use case.)\n   *\n   * Warning: You can easily introduce performance bugs in your application by using this method\n   * inappropriately.\n   */;\n  _proto.withChangesForTables = function withChangesForTables(tables) {\n    var _this4 = this;\n    var changesSignals = tables.map(function (table) {\n      return _this4.collections.get(table).changes;\n    });\n    return _rx.merge.apply(void 0, (0, _toConsumableArray2.default)(changesSignals)).pipe((0, _rx.startWith)(null));\n  };\n  /**\n   * Notifies `subscriber` on change in any of the passed tables.\n   *\n   * A single notification will be sent per `database.batch()` call.\n   * (Currently, no details about the changes made are provided, only a signal, but this behavior\n   * might change. Currently, subscribers are called before `withChangesForTables`).\n   *\n   * Warning: You can easily introduce performance bugs in your application by using this method\n   * inappropriately.\n   */\n  _proto.experimentalSubscribe = function experimentalSubscribe(tables, subscriber, debugInfo) {\n    var _this5 = this;\n    if (!tables.length) {\n      return _fp.noop;\n    }\n    var entry = [tables, subscriber, debugInfo];\n    this._subscribers.push(entry);\n    return function () {\n      var idx = _this5._subscribers.indexOf(entry);\n      -1 !== idx && _this5._subscribers.splice(idx, 1);\n    };\n  };\n  /**\n   * Resets the database\n   *\n   * This permanently deletes the database (all records, metadata, and `LocalStorage`) and sets\n   * up an empty database.\n   *\n   * Special care must be taken to safely reset the database. Ideally, you should reset your app\n   * to an empty / \"logging out\" state while doing this. Specifically:\n   *\n   * - You MUST NOT hold onto Watermelon records other than this `Database`. Do not keep references\n   *   to records, collections, or any other objects from before database reset\n   * - You MUST NOT observe any Watermelon state. All Database, Collection, Query, and Model\n   *   observers/subscribers should be disposed of before resetting\n   * - You SHOULD NOT have any pending (queued) Readers or Writers. Pending work will be aborted\n   *   (rejected with an error)\n   */\n  _proto.unsafeResetDatabase = function unsafeResetDatabase() {\n    return new Promise(function ($return, $error) {\n      var $Try_3_Finally = function ($Try_3_Exit) {\n        return function ($Try_3_Value) {\n          try {\n            this._isBeingReset = false;\n            return $Try_3_Exit && $Try_3_Exit.call(this, $Try_3_Value);\n          } catch ($boundEx) {\n            return $error($boundEx);\n          }\n        }.bind(this);\n      }.bind(this);\n      var adapter, ErrorAdapter;\n      this._ensureInWriter(\"Database.unsafeResetDatabase()\");\n      var $Try_3_Post = function () {\n        try {\n          return $return();\n        } catch ($boundEx) {\n          return $error($boundEx);\n        }\n      };\n      var $Try_3_Catch = function ($exception_4) {\n        try {\n          throw $exception_4;\n        } catch ($boundEx) {\n          return $Try_3_Finally($error)($boundEx);\n        }\n      };\n      try {\n        this._isBeingReset = true;\n        // First kill actions, to ensure no more traffic to adapter happens\n        this._workQueue._abortPendingWork();\n\n        // Kill ability to call adapter methods during reset (to catch bugs if someone does this)\n        ({\n          adapter: adapter\n        } = this);\n        ErrorAdapter = require('../adapters/error').default;\n        this.adapter = new ErrorAdapter();\n\n        // Check for illegal subscribers\n        if (this._subscribers.length) {\n          // TODO: This should be an error, not a console.log, but actually useful diagnostics are necessary for this to work, otherwise people will be confused\n          // eslint-disable-next-line no-console\n          console.log(\"Application error! Unexpected \".concat(this._subscribers.length, \" Database subscribers were detected during database.unsafeResetDatabase() call. App should not hold onto subscriptions or Watermelon objects while resetting database.\"));\n          // eslint-disable-next-line no-console\n          console.log(this._subscribers);\n          this._subscribers = [];\n        }\n\n        // Clear the database\n        return Promise.resolve(adapter.unsafeResetDatabase()).then(function () {\n          try {\n            // Only now clear caches, since there may have been queued fetches from DB still bringing in items to cache\n            Object.values(this.collections.map).forEach(function (collection) {\n              // $FlowFixMe\n              collection._cache.unsafeClear();\n            });\n\n            // Restore working Database\n            this._resetCount += 1;\n            this.adapter = adapter;\n            return $Try_3_Finally($Try_3_Post)();\n          } catch ($boundEx) {\n            return $Try_3_Catch($boundEx);\n          }\n        }.bind(this), $Try_3_Catch);\n      } catch ($exception_4) {\n        $Try_3_Catch($exception_4)\n      }\n    }.bind(this));\n  };\n  _proto._ensureInWriter = function _ensureInWriter(diagnosticMethodName) {\n    (0, _common.invariant)(this._workQueue.isWriterRunning, \"\".concat(diagnosticMethodName, \" can only be called from inside of a Writer. See docs for more details.\"));\n  }\n\n  // (experimental) puts Database in a broken state\n  // TODO: Not used anywhere yet\n  ;\n  _proto._fatalError = function _fatalError(error) {\n    if (!experimentalAllowsFatalError) {\n      _common.logger.warn('Database is now broken, but experimentalAllowsFatalError has not been enabled to do anything about it...');\n      return;\n    }\n    this._isBroken = true;\n    _common.logger.error('Database is broken. App must be reloaded before continuing.');\n\n    // TODO: Passing this to an adapter feels wrong, but it's tricky.\n    // $FlowFixMe\n    if (this.adapter.underlyingAdapter._fatalError) {\n      // $FlowFixMe\n      this.adapter.underlyingAdapter._fatalError(error);\n    }\n  };\n  (0, _createClass2.default)(Database, [{\n    key: \"localStorage\",\n    get: function get() {\n      if (!this._localStorage) {\n        var LocalStorageClass = require('./LocalStorage').default;\n        this._localStorage = new LocalStorageClass(this);\n      }\n      return this._localStorage;\n    }\n  }]);\n  return Database;\n}();\nexports.default = Database;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}