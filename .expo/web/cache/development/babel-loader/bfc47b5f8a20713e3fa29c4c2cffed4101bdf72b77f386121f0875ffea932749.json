{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nexports.__esModule = true;\nexports.nullValue = nullValue;\nexports.sanitizedRaw = sanitizedRaw;\nexports.setRawSanitized = setRawSanitized;\nvar _randomId = _interopRequireDefault(require(\"../utils/common/randomId\"));\nfunction isValidNumber(value) {\n  return 'number' === typeof value && value === value && value !== Infinity && value !== -Infinity;\n}\nfunction _setRaw(raw, key, value, columnSchema) {\n  var type = columnSchema.type,\n    isOptional = columnSchema.isOptional;\n  if ('string' === type) {\n    if ('string' === typeof value) {\n      raw[key] = value;\n    } else {\n      raw[key] = isOptional ? null : '';\n    }\n  } else if ('boolean' === type) {\n    if ('boolean' === typeof value) {\n      raw[key] = value;\n    } else if (1 === value || 0 === value) {\n      raw[key] = Boolean(value);\n    } else {\n      raw[key] = isOptional ? null : false;\n    }\n  } else {\n    if (isValidNumber(value)) {\n      raw[key] = value || 0;\n    } else {\n      raw[key] = isOptional ? null : 0;\n    }\n  }\n}\nfunction isValidStatus(value) {\n  return 'created' === value || 'updated' === value || 'deleted' === value || 'synced' === value;\n}\nfunction sanitizedRaw(dirtyRaw, tableSchema) {\n  var id = dirtyRaw.id,\n    _status = dirtyRaw._status,\n    _changed = dirtyRaw._changed;\n  var raw = {};\n  if ('string' === typeof id) {\n    raw.id = id;\n    raw._status = isValidStatus(_status) ? _status : 'created';\n    raw._changed = 'string' === typeof _changed ? _changed : '';\n  } else {\n    raw.id = (0, _randomId.default)();\n    raw._status = 'created';\n    raw._changed = '';\n  }\n  var columns = tableSchema.columnArray;\n  for (var i = 0, len = columns.length; i < len; i += 1) {\n    var columnSchema = columns[i];\n    var key = columnSchema.name;\n    var value = Object.prototype.hasOwnProperty.call(dirtyRaw, key) ? dirtyRaw[key] : null;\n    _setRaw(raw, key, value, columnSchema);\n  }\n  return raw;\n}\nfunction setRawSanitized(rawRecord, columnName, value, columnSchema) {\n  _setRaw(rawRecord, columnName, value, columnSchema);\n}\nfunction nullValue(columnSchema) {\n  var isOptional = columnSchema.isOptional,\n    type = columnSchema.type;\n  if (isOptional) {\n    return null;\n  } else if ('string' === type) {\n    return '';\n  } else if ('number' === type) {\n    return 0;\n  } else if ('boolean' === type) {\n    return false;\n  }\n  throw new Error(\"Unknown type for column schema \".concat(JSON.stringify(columnSchema)));\n}","map":{"version":3,"names":["_interopRequireDefault","require","exports","__esModule","nullValue","sanitizedRaw","setRawSanitized","_randomId","isValidNumber","value","Infinity","_setRaw","raw","key","columnSchema","type","isOptional","Boolean","isValidStatus","dirtyRaw","tableSchema","id","_status","_changed","default","columns","columnArray","i","len","length","name","Object","prototype","hasOwnProperty","call","rawRecord","columnName","Error","concat","JSON","stringify"],"sources":["/app/node_modules/@nozbe/watermelondb/RawRecord/index.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nexports.__esModule = true;\nexports.nullValue = nullValue;\nexports.sanitizedRaw = sanitizedRaw;\nexports.setRawSanitized = setRawSanitized;\nvar _randomId = _interopRequireDefault(require(\"../utils/common/randomId\"));\n/* eslint-disable no-lonely-if */\n/* eslint-disable no-self-compare */\n// a number, but not NaN (NaN !== NaN) or Infinity\nfunction isValidNumber(value) {\n  return 'number' === typeof value && value === value && value !== Infinity && value !== -Infinity;\n}\n\n// Note: This is performance-critical code\nfunction _setRaw(raw, key, value, columnSchema) {\n  var {\n    type: type,\n    isOptional: isOptional\n  } = columnSchema;\n\n  // If the value is wrong type or invalid, it's set to `null` (if optional) or empty value ('', 0, false)\n  if ('string' === type) {\n    if ('string' === typeof value) {\n      raw[key] = value;\n    } else {\n      raw[key] = isOptional ? null : '';\n    }\n  } else if ('boolean' === type) {\n    if ('boolean' === typeof value) {\n      raw[key] = value;\n    } else if (1 === value || 0 === value) {\n      // Exception to the standard rule â€” because SQLite turns true/false into 1/0\n      raw[key] = Boolean(value);\n    } else {\n      raw[key] = isOptional ? null : false;\n    }\n  } else {\n    // type = number\n    // Treat NaN and Infinity as null\n    if (isValidNumber(value)) {\n      raw[key] = value || 0;\n    } else {\n      raw[key] = isOptional ? null : 0;\n    }\n  }\n}\nfunction isValidStatus(value) {\n  return 'created' === value || 'updated' === value || 'deleted' === value || 'synced' === value;\n}\n\n// Transforms a dirty raw record object into a trusted sanitized RawRecord according to passed TableSchema\n// TODO: Should we make this public API for advanced users?\nfunction sanitizedRaw(dirtyRaw, tableSchema) {\n  var {\n    id: id,\n    _status: _status,\n    _changed: _changed\n  } = dirtyRaw;\n\n  // This is called with `{}` when making a new record, so we need to set a new ID, status\n  // Also: If an existing has one of those fields broken, we're screwed. Safest to treat it as a\n  // new record (so that it gets synced)\n\n  // TODO: Think about whether prototypeless objects are a useful mitigation\n  // const raw = Object.create(null) // create a prototypeless object\n  var raw = {};\n  if ('string' === typeof id) {\n    // TODO: Can we trust IDs passed? Maybe we want to split this implementation, depending on whether\n    // this is used on implicitly-trusted (persisted or Watermelon-created) records, or if this is user input?\n    raw.id = id;\n    raw._status = isValidStatus(_status) ? _status : 'created';\n    raw._changed = 'string' === typeof _changed ? _changed : '';\n  } else {\n    raw.id = (0, _randomId.default)();\n    raw._status = 'created';\n    raw._changed = '';\n  }\n\n  // faster than Object.values on a map\n  var columns = tableSchema.columnArray;\n  for (var i = 0, len = columns.length; i < len; i += 1) {\n    var columnSchema = columns[i];\n    var key = columnSchema.name;\n    // TODO: Check performance\n    // $FlowFixMe\n    var value = Object.prototype.hasOwnProperty.call(dirtyRaw, key) ? dirtyRaw[key] : null;\n    _setRaw(raw, key, value, columnSchema);\n  }\n  return raw;\n}\n\n// Modifies passed rawRecord by setting sanitized `value` to `columnName`\n// Note: Assumes columnName exists and columnSchema matches the name\nfunction setRawSanitized(rawRecord, columnName, value, columnSchema) {\n  _setRaw(rawRecord, columnName, value, columnSchema);\n}\nfunction nullValue(columnSchema) {\n  var {\n    isOptional: isOptional,\n    type: type\n  } = columnSchema;\n  if (isOptional) {\n    return null;\n  } else if ('string' === type) {\n    return '';\n  } else if ('number' === type) {\n    return 0;\n  } else if ('boolean' === type) {\n    return false;\n  }\n  throw new Error(\"Unknown type for column schema \".concat(JSON.stringify(columnSchema)));\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}