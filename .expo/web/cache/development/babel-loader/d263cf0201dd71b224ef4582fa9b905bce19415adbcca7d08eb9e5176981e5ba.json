{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nexports.__esModule = true;\nexports.default = subscribeToQueryWithColumns;\nvar _identicalArrays = _interopRequireDefault(require(\"../../utils/fp/identicalArrays\"));\nvar _subscribeToSimpleQuery = _interopRequireDefault(require(\"../subscribeToSimpleQuery\"));\nvar _subscribeToQueryReloading = _interopRequireDefault(require(\"../subscribeToQueryReloading\"));\nvar _canEncode = _interopRequireDefault(require(\"../encodeMatcher/canEncode\"));\nvar getRecordState = function getRecordState(record, columnNames) {\n  var state = [];\n  var raw = record._raw;\n  for (var i = 0, len = columnNames.length; i < len; i++) {\n    state.push(raw[columnNames[i]]);\n  }\n  return state;\n};\nvar recordStatesEqual = _identicalArrays.default;\nfunction subscribeToQueryWithColumns(query, columnNames, subscriber) {\n  var unsubscribed = false;\n  var sourceIsFetching = true;\n  var hasPendingColumnChanges = false;\n  var firstEmission = true;\n  var observedRecords = [];\n  var recordStates = new Map();\n  var emitCopy = function emitCopy(records) {\n    unsubscribed || subscriber(records.slice(0));\n  };\n  var canUseSimpleObservation = (0, _canEncode.default)(query.description);\n  var subscribeToSource = canUseSimpleObservation ? function (observer) {\n    return (0, _subscribeToSimpleQuery.default)(query, observer, true);\n  } : function (observer) {\n    return (0, _subscribeToQueryReloading.default)(query, observer, true);\n  };\n  var collectionUnsubscribe = query.collection.experimentalSubscribe(function (changeSet) {\n    var hasColumnChanges = false;\n    changeSet.forEach(function (_ref) {\n      var record = _ref.record,\n        type = _ref.type;\n      if ('updated' !== type) {\n        return;\n      }\n      var previousState = recordStates.get(record.id);\n      if (!previousState) {\n        return;\n      }\n      var newState = getRecordState(record, columnNames);\n      if (!recordStatesEqual(previousState, newState)) {\n        recordStates.set(record.id, newState);\n        hasColumnChanges = true;\n      }\n    });\n    if (hasColumnChanges) {\n      if (sourceIsFetching || !!canUseSimpleObservation) {\n        hasPendingColumnChanges = true;\n      } else {\n        emitCopy(observedRecords);\n      }\n    }\n  }, {\n    name: 'subscribeToQueryWithColumns',\n    query: query,\n    columnNames: columnNames\n  });\n  var sourceUnsubscribe = subscribeToSource(function (recordsOrStatus) {\n    if (false === recordsOrStatus) {\n      sourceIsFetching = true;\n      return;\n    }\n    sourceIsFetching = false;\n    var records = recordsOrStatus;\n    var shouldEmit = firstEmission || hasPendingColumnChanges || !(0, _identicalArrays.default)(records, observedRecords);\n    hasPendingColumnChanges = false;\n    firstEmission = false;\n    var arrayDifference = require(\"../../utils/fp/arrayDifference\").default;\n    var _arrayDifference = arrayDifference(observedRecords, records),\n      added = _arrayDifference.added,\n      removed = _arrayDifference.removed;\n    observedRecords = records;\n    removed.forEach(function (record) {\n      recordStates.delete(record.id);\n    });\n    added.forEach(function (newRecord) {\n      recordStates.set(newRecord.id, getRecordState(newRecord, columnNames));\n    });\n    shouldEmit && emitCopy(records);\n  });\n  return function () {\n    unsubscribed = true;\n    sourceUnsubscribe();\n    collectionUnsubscribe();\n  };\n}","map":{"version":3,"names":["_interopRequireDefault","require","exports","__esModule","default","subscribeToQueryWithColumns","_identicalArrays","_subscribeToSimpleQuery","_subscribeToQueryReloading","_canEncode","getRecordState","record","columnNames","state","raw","_raw","i","len","length","push","recordStatesEqual","query","subscriber","unsubscribed","sourceIsFetching","hasPendingColumnChanges","firstEmission","observedRecords","recordStates","Map","emitCopy","records","slice","canUseSimpleObservation","description","subscribeToSource","observer","collectionUnsubscribe","collection","experimentalSubscribe","changeSet","hasColumnChanges","forEach","_ref","type","previousState","get","id","newState","set","name","sourceUnsubscribe","recordsOrStatus","shouldEmit","arrayDifference","_arrayDifference","added","removed","delete","newRecord"],"sources":["/app/node_modules/@nozbe/watermelondb/observation/subscribeToQueryWithColumns/index.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nexports.__esModule = true;\nexports.default = subscribeToQueryWithColumns;\nvar _identicalArrays = _interopRequireDefault(require(\"../../utils/fp/identicalArrays\"));\nvar _subscribeToSimpleQuery = _interopRequireDefault(require(\"../subscribeToSimpleQuery\"));\nvar _subscribeToQueryReloading = _interopRequireDefault(require(\"../subscribeToQueryReloading\"));\nvar _canEncode = _interopRequireDefault(require(\"../encodeMatcher/canEncode\"));\nvar getRecordState = function (record, columnNames) {\n  var state = [];\n  var raw = record._raw;\n  for (var i = 0, len = columnNames.length; i < len; i++) {\n    // $FlowFixMe\n    state.push(raw[columnNames[i]]);\n  }\n  return state;\n};\n\n// Invariant: same length and order of keys!\nvar recordStatesEqual = _identicalArrays.default;\n\n// Observes the given observable list of records, and in those records,\n// changes to given `rawFields`\n//\n// Emits a list of records when:\n// - source observable emits a new list\n// - any of the records in the list has any of the given fields changed\n//\n// TODO: Possible future optimizations:\n// - simpleObserver could emit added/removed events, and this could operate on those instead of\n//   re-deriving the same thing. For reloadingObserver, a Rx adapter could be fitted\n// - multiple levels of array copying could probably be omitted\n\nfunction subscribeToQueryWithColumns(query, columnNames, subscriber) {\n  // State kept for comparison between emissions\n  var unsubscribed = false;\n  var sourceIsFetching = true; // do not emit record-level changes while source is fetching new data\n  var hasPendingColumnChanges = false;\n  var firstEmission = true;\n  var observedRecords = [];\n  var recordStates = new Map();\n  var emitCopy = function (records) {\n    unsubscribed || subscriber(records.slice(0));\n  };\n\n  // NOTE:\n  // Observing both the source subscription and changes to columns is very tricky\n  // if we want to avoid unnecessary emissions (we do, because that triggers wasted app renders).\n  // The compounding factor is that we have two methods of observation: simpleObserver which is\n  // synchronous, and reloadingObserver, which is asynchronous.\n  //\n  // For reloadingObserver, we use `reloadingObserverWithStatus` to be notified that an async DB query\n  // has begun. If it did, we will not emit column-only changes until query has come back.\n  //\n  // For simpleObserver, we need to configure it to always emit on collection changes. This is a\n  // workaround to solve a race condition - collection observation for column check will always\n  // emit first, but we don't know if the list of observed records isn't about to change, so we\n  // flag, and wait for source response.\n  //\n  // FIXME: The above explanation is outdated in practice because modern WatermelonDB uses synchronous\n  // adapters... However, JSI on Android isn't yet fully shipped (so this is currently broken), and\n  // we may get back to some asynchronicity where appropriate...\n\n  // prepare source observable\n  // TODO: On one hand it would be nice to bring in the source logic to this function to optimize\n  // on the other, it would be good to have source provided as Observable, not Query\n  // so that we can reuse cached responses -- but they don't have compatible format\n  var canUseSimpleObservation = (0, _canEncode.default)(query.description);\n  var subscribeToSource = canUseSimpleObservation ? function (observer) {\n    return (0, _subscribeToSimpleQuery.default)(query, observer, true);\n  } : function (observer) {\n    return (0, _subscribeToQueryReloading.default)(query, observer, true);\n  };\n  var collectionUnsubscribe = query.collection.experimentalSubscribe(\n  // eslint-disable-next-line prefer-arrow-callback\n  function (changeSet) {\n    var hasColumnChanges = false;\n    // Can't use `Array.some`, because then we'd skip saving record state for relevant records\n    changeSet.forEach(function ({\n      record: record,\n      type: type\n    }) {\n      // See if change is relevant to our query\n      if ('updated' !== type) {\n        return;\n      }\n      var previousState = recordStates.get(record.id);\n      if (!previousState) {\n        return;\n      }\n\n      // Check if record changed one of its observed fields\n      var newState = getRecordState(record, columnNames);\n      if (!recordStatesEqual(previousState, newState)) {\n        recordStates.set(record.id, newState);\n        hasColumnChanges = true;\n      }\n    });\n    if (hasColumnChanges) {\n      if (sourceIsFetching || !!canUseSimpleObservation) {\n        // Mark change; will emit on source emission to avoid duplicate emissions\n        hasPendingColumnChanges = true;\n      } else {\n        emitCopy(observedRecords);\n      }\n    }\n  }, {\n    name: 'subscribeToQueryWithColumns',\n    query: query,\n    columnNames: columnNames\n  });\n\n  // Observe the source records list (list of records matching a query)\n  // eslint-disable-next-line prefer-arrow-callback\n  var sourceUnsubscribe = subscribeToSource(function (recordsOrStatus) {\n    // $FlowFixMe\n    if (false === recordsOrStatus) {\n      sourceIsFetching = true;\n      return;\n    }\n    sourceIsFetching = false;\n\n    // Emit changes if one of observed columns changed OR list of matching records changed\n    var records = recordsOrStatus;\n    var shouldEmit = firstEmission || hasPendingColumnChanges || !(0, _identicalArrays.default)(records, observedRecords);\n    hasPendingColumnChanges = false;\n    firstEmission = false;\n\n    // Find changes, and save current list for comparison on next emission\n    var arrayDifference = require('../../utils/fp/arrayDifference').default;\n    var {\n      added: added,\n      removed: removed\n    } = arrayDifference(observedRecords, records);\n    observedRecords = records;\n\n    // Unsubscribe from records removed from list\n    removed.forEach(function (record) {\n      recordStates.delete(record.id);\n    });\n\n    // Save current record state for later comparison\n    added.forEach(function (newRecord) {\n      recordStates.set(newRecord.id, getRecordState(newRecord, columnNames));\n    });\n\n    // Emit\n    shouldEmit && emitCopy(records);\n  });\n  return function () {\n    unsubscribed = true;\n    sourceUnsubscribe();\n    collectionUnsubscribe();\n  };\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}