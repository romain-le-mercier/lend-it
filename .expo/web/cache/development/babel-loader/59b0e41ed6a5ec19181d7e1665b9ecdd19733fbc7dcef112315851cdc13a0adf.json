{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nexports.__esModule = true;\nexports.default = encodeQuery;\nvar _invariant = _interopRequireDefault(require(\"../../../../utils/common/invariant\"));\nvar _likeToRegexp = _interopRequireDefault(require(\"../../../../utils/fp/likeToRegexp\"));\nvar weakNotNull = {\n  $not: {\n    $aeq: null\n  }\n};\nvar encodeComparison = function encodeComparison(comparison, value) {\n  var operator = comparison.operator;\n  if (comparison.right.column) {\n    switch (operator) {\n      case 'eq':\n        return {\n          $$aeq: value\n        };\n      case 'notEq':\n        return {\n          $not: {\n            $$aeq: value\n          }\n        };\n      case 'gt':\n        return {\n          $$gt: value\n        };\n      case 'gte':\n        return {\n          $$gte: value\n        };\n      case 'weakGt':\n        return {\n          $$gt: value\n        };\n      case 'lt':\n        return {\n          $and: [{\n            $$lt: value\n          }, weakNotNull]\n        };\n      case 'lte':\n        return {\n          $and: [{\n            $$lte: value\n          }, weakNotNull]\n        };\n      default:\n        throw new Error(\"Illegal operator \".concat(operator, \" for column comparisons\"));\n    }\n  } else {\n    switch (operator) {\n      case 'eq':\n        return {\n          $aeq: value\n        };\n      case 'notEq':\n        return {\n          $not: {\n            $aeq: value\n          }\n        };\n      case 'gt':\n        return {\n          $gt: value\n        };\n      case 'gte':\n        return {\n          $gte: value\n        };\n      case 'weakGt':\n        return {\n          $gt: value\n        };\n      case 'lt':\n        return {\n          $and: [{\n            $lt: value\n          }, weakNotNull]\n        };\n      case 'lte':\n        return {\n          $and: [{\n            $lte: value\n          }, weakNotNull]\n        };\n      case 'oneOf':\n        return {\n          $in: value\n        };\n      case 'notIn':\n        return {\n          $and: [{\n            $nin: value\n          }, weakNotNull]\n        };\n      case 'between':\n        return {\n          $between: value\n        };\n      case 'like':\n        return {\n          $regex: (0, _likeToRegexp.default)(value)\n        };\n      case 'notLike':\n        return {\n          $and: [{\n            $not: {\n              $eq: null\n            }\n          }, {\n            $not: {\n              $regex: (0, _likeToRegexp.default)(value)\n            }\n          }]\n        };\n      case 'includes':\n        return {\n          $containsString: value\n        };\n      default:\n        throw new Error(\"Unknown operator \".concat(operator));\n    }\n  }\n};\nvar columnCompRequiresColumnNotNull = {\n  gt: true,\n  gte: true,\n  lt: true,\n  lte: true\n};\nvar encodeWhereDescription = function encodeWhereDescription(_ref7) {\n  var left = _ref7.left,\n    comparison = _ref7.comparison;\n  var _ref5;\n  var operator = comparison.operator,\n    right = comparison.right;\n  var col = left;\n  var comparisonRight = right.column || right.values || right.value;\n  if ('string' === typeof right.value) {\n    if ('eq' === operator) {\n      var _ref;\n      return _ref = {}, _ref[col] = {\n        $eq: comparisonRight\n      }, _ref;\n    } else if ('notEq' === operator) {\n      var _ref2;\n      return _ref2 = {}, _ref2[col] = {\n        $ne: comparisonRight\n      }, _ref2;\n    }\n  }\n  var colName = right.column;\n  var encodedComparison = encodeComparison(comparison, comparisonRight);\n  if (colName && columnCompRequiresColumnNotNull[operator]) {\n    var _ref3, _ref4;\n    return {\n      $and: [(_ref3 = {}, _ref3[col] = encodedComparison, _ref3), (_ref4 = {}, _ref4[colName] = weakNotNull, _ref4)]\n    };\n  }\n  return _ref5 = {}, _ref5[col] = encodedComparison, _ref5;\n};\nvar encodeCondition = function encodeCondition(associations) {\n  return function (clause) {\n    switch (clause.type) {\n      case 'and':\n        return encodeAnd(associations, clause);\n      case 'or':\n        return encodeOr(associations, clause);\n      case 'where':\n        return encodeWhereDescription(clause);\n      case 'on':\n        return encodeJoin(associations, clause);\n      case 'loki':\n        return clause.expr;\n      default:\n        throw new Error(\"Unknown clause \".concat(clause.type));\n    }\n  };\n};\nvar encodeConditions = function encodeConditions(associations, conditions) {\n  return conditions.map(encodeCondition(associations));\n};\nvar encodeAndOr = function encodeAndOr(op) {\n  return function (associations, clause) {\n    var _ref6;\n    var conditions = encodeConditions(associations, clause.conditions);\n    return 1 === conditions.length ? conditions[0] : (_ref6 = {}, _ref6[op] = conditions, _ref6);\n  };\n};\nvar encodeAnd = encodeAndOr('$and');\nvar encodeOr = encodeAndOr('$or');\nvar concatRawQueries = function concatRawQueries(queries) {\n  switch (queries.length) {\n    case 0:\n      return undefined;\n    case 1:\n      return queries[0];\n    default:\n      return {\n        $and: queries\n      };\n  }\n};\nvar encodeRootConditions = function encodeRootConditions(associations, conditions) {\n  return concatRawQueries(encodeConditions(associations, conditions));\n};\nvar encodeJoin = function encodeJoin(associations, on) {\n  var table = on.table,\n    conditions = on.conditions;\n  var association = associations.find(function (_ref8) {\n    var to = _ref8.to;\n    return table === to;\n  });\n  (0, _invariant.default)(association, 'To nest Q.on inside Q.and/Q.or you must explicitly declare Q.experimentalJoinTables at the beginning of the query');\n  var info = association.info;\n  return {\n    $join: {\n      table: table,\n      query: encodeRootConditions(associations, conditions),\n      mapKey: 'belongs_to' === info.type ? 'id' : info.foreignKey,\n      joinKey: 'belongs_to' === info.type ? info.key : 'id'\n    }\n  };\n};\nfunction encodeQuery(query) {\n  var table = query.table,\n    _query$description = query.description,\n    where = _query$description.where,\n    joinTables = _query$description.joinTables,\n    sql = _query$description.sql,\n    associations = query.associations;\n  (0, _invariant.default)(!sql, '[Loki] Q.unsafeSqlQuery are not supported with LokiJSAdapter');\n  return {\n    table: table,\n    query: encodeRootConditions(associations, where),\n    hasJoins: !!joinTables.length\n  };\n}","map":{"version":3,"names":["_interopRequireDefault","require","exports","__esModule","default","encodeQuery","_invariant","_likeToRegexp","weakNotNull","$not","$aeq","encodeComparison","comparison","value","operator","right","column","$$aeq","$$gt","$$gte","$and","$$lt","$$lte","Error","concat","$gt","$gte","$lt","$lte","$in","$nin","$between","$regex","$eq","$containsString","columnCompRequiresColumnNotNull","gt","gte","lt","lte","encodeWhereDescription","_ref7","left","_ref5","col","comparisonRight","values","_ref","_ref2","$ne","colName","encodedComparison","_ref3","_ref4","encodeCondition","associations","clause","type","encodeAnd","encodeOr","encodeJoin","expr","encodeConditions","conditions","map","encodeAndOr","op","_ref6","length","concatRawQueries","queries","undefined","encodeRootConditions","on","table","association","find","_ref8","to","info","$join","query","mapKey","foreignKey","joinKey","key","_query$description","description","where","joinTables","sql","hasJoins"],"sources":["/app/node_modules/@nozbe/watermelondb/adapters/lokijs/worker/encodeQuery/index.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nexports.__esModule = true;\nexports.default = encodeQuery;\nvar _invariant = _interopRequireDefault(require(\"../../../../utils/common/invariant\"));\nvar _likeToRegexp = _interopRequireDefault(require(\"../../../../utils/fp/likeToRegexp\"));\n/* eslint-disable no-use-before-define */\n// don't import whole `utils` to keep worker size small\nvar weakNotNull = {\n  $not: {\n    $aeq: null\n  }\n};\nvar encodeComparison = function (comparison, value) {\n  // TODO: It's probably possible to improve performance of those operators by making them\n  // binary-search compatible (i.e. don't use $and, $not)\n  // TODO: We might be able to use $jgt, $jbetween, etc. â€” but ensure the semantics are right\n  // and it won't break indexing\n\n  var {\n    operator: operator\n  } = comparison;\n  if (comparison.right.column) {\n    // Encode for column comparisons\n    switch (operator) {\n      case 'eq':\n        return {\n          $$aeq: value\n        };\n      case 'notEq':\n        return {\n          $not: {\n            $$aeq: value\n          }\n        };\n      case 'gt':\n        return {\n          $$gt: value\n        };\n      case 'gte':\n        return {\n          $$gte: value\n        };\n      case 'weakGt':\n        return {\n          $$gt: value\n        };\n      case 'lt':\n        return {\n          $and: [{\n            $$lt: value\n          }, weakNotNull]\n        };\n      case 'lte':\n        return {\n          $and: [{\n            $$lte: value\n          }, weakNotNull]\n        };\n      default:\n        throw new Error(\"Illegal operator \".concat(operator, \" for column comparisons\"));\n    }\n  } else {\n    switch (operator) {\n      case 'eq':\n        return {\n          $aeq: value\n        };\n      case 'notEq':\n        return {\n          $not: {\n            $aeq: value\n          }\n        };\n      case 'gt':\n        return {\n          $gt: value\n        };\n      case 'gte':\n        return {\n          $gte: value\n        };\n      case 'weakGt':\n        return {\n          $gt: value\n        };\n      // Note: yup, this is correct (for non-column comparisons)\n      case 'lt':\n        return {\n          $and: [{\n            $lt: value\n          }, weakNotNull]\n        };\n      case 'lte':\n        return {\n          $and: [{\n            $lte: value\n          }, weakNotNull]\n        };\n      case 'oneOf':\n        return {\n          $in: value\n        };\n      case 'notIn':\n        return {\n          $and: [{\n            $nin: value\n          }, weakNotNull]\n        };\n      case 'between':\n        return {\n          $between: value\n        };\n      case 'like':\n        return {\n          $regex: (0, _likeToRegexp.default)(value)\n        };\n      case 'notLike':\n        return {\n          $and: [{\n            $not: {\n              $eq: null\n            }\n          }, {\n            $not: {\n              $regex: (0, _likeToRegexp.default)(value)\n            }\n          }]\n        };\n      case 'includes':\n        return {\n          $containsString: value\n        };\n      default:\n        throw new Error(\"Unknown operator \".concat(operator));\n    }\n  }\n};\nvar columnCompRequiresColumnNotNull = {\n  gt: true,\n  gte: true,\n  lt: true,\n  lte: true\n};\nvar encodeWhereDescription = function ({\n  left: left,\n  comparison: comparison\n}) {\n  var _ref5;\n  var {\n    operator: operator,\n    right: right\n  } = comparison;\n  var col = left;\n  // $FlowFixMe - NOTE: order of ||s is important here, since .value can be falsy, but .column and .values are either truthy or are undefined\n  var comparisonRight = right.column || right.values || right.value;\n  if ('string' === typeof right.value) {\n    // we can do fast path as we know that eq and aeq do the same thing for strings\n    if ('eq' === operator) {\n      var _ref;\n      return _ref = {}, _ref[col] = {\n        $eq: comparisonRight\n      }, _ref;\n    } else if ('notEq' === operator) {\n      var _ref2;\n      return _ref2 = {}, _ref2[col] = {\n        $ne: comparisonRight\n      }, _ref2;\n    }\n  }\n  var colName = right.column;\n  var encodedComparison = encodeComparison(comparison, comparisonRight);\n  if (colName && columnCompRequiresColumnNotNull[operator]) {\n    var _ref3, _ref4;\n    return {\n      $and: [(_ref3 = {}, _ref3[col] = encodedComparison, _ref3), (_ref4 = {}, _ref4[colName] = weakNotNull, _ref4)]\n    };\n  }\n  return _ref5 = {}, _ref5[col] = encodedComparison, _ref5;\n};\nvar encodeCondition = function (associations) {\n  return function (clause) {\n    switch (clause.type) {\n      case 'and':\n        return encodeAnd(associations, clause);\n      case 'or':\n        return encodeOr(associations, clause);\n      case 'where':\n        return encodeWhereDescription(clause);\n      case 'on':\n        return encodeJoin(associations, clause);\n      case 'loki':\n        return clause.expr;\n      default:\n        throw new Error(\"Unknown clause \".concat(clause.type));\n    }\n  };\n};\nvar encodeConditions = function (associations, conditions) {\n  return conditions.map(encodeCondition(associations));\n};\nvar encodeAndOr = function (op) {\n  return function (associations, clause) {\n    var _ref6;\n    var conditions = encodeConditions(associations, clause.conditions);\n    // flatten\n    return 1 === conditions.length ? conditions[0] : (_ref6 = {}, _ref6[op] = conditions, _ref6);\n  };\n};\nvar encodeAnd = encodeAndOr('$and');\nvar encodeOr = encodeAndOr('$or');\n\n// Note: empty query returns `undefined` because\n// Loki's Collection.count() works but count({}) doesn't\nvar concatRawQueries = function (queries) {\n  switch (queries.length) {\n    case 0:\n      return undefined;\n    case 1:\n      return queries[0];\n    default:\n      return {\n        $and: queries\n      };\n  }\n};\nvar encodeRootConditions = function (associations, conditions) {\n  return concatRawQueries(encodeConditions(associations, conditions));\n};\nvar encodeJoin = function (associations, on) {\n  var {\n    table: table,\n    conditions: conditions\n  } = on;\n  var association = associations.find(function ({\n    to: to\n  }) {\n    return table === to;\n  });\n  (0, _invariant.default)(association, 'To nest Q.on inside Q.and/Q.or you must explicitly declare Q.experimentalJoinTables at the beginning of the query');\n  var {\n    info: info\n  } = association;\n  return {\n    $join: {\n      table: table,\n      query: encodeRootConditions(associations, conditions),\n      mapKey: 'belongs_to' === info.type ? 'id' : info.foreignKey,\n      joinKey: 'belongs_to' === info.type ? info.key : 'id'\n    }\n  };\n};\nfunction encodeQuery(query) {\n  var {\n    table: table,\n    description: {\n      where: where,\n      joinTables: joinTables,\n      sql: sql\n    },\n    associations: associations\n  } = query;\n  (0, _invariant.default)(!sql, '[Loki] Q.unsafeSqlQuery are not supported with LokiJSAdapter');\n  return {\n    table: table,\n    query: encodeRootConditions(associations, where),\n    hasJoins: !!joinTables.length\n  };\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}